# Cloud Build: construye, testea, escanea, genera SBOM, firma y despliega microservicios SGA.
#
# Ejemplos:
#   gcloud builds submit --config=cloudbuild.yaml
#   gcloud builds submit --config=cloudbuild.yaml --substitutions=_SERVICES="core_sga ai_engine",_DEPLOY="true",_SIGN="true",_SBOM="true"
#   gcloud builds submit --config=cloudbuild.yaml --substitutions=_EXTRA_TAG="staging",_SCAN="true"
#
# Ajusta las sustituciones según lo necesario.

timeout: 5400s
options:
  logging: CLOUD_LOGGING_ONLY
  machineType: E2_HIGHCPU_8

substitutions:
  _SERVICES: "core_sga,ai_engine,risk_engine,compliance_engine,objectives_engine,ghg_engine,audit_engine,auth_engine,reporting_engine"
  _EXTRA_TAG: ""
  _DEPLOY: "false"
  _REGION: "southamerica-east1"
  _AR_REGION: "us-central1"
  _BUILDER: "kaniko"                # kaniko | docker
  _KANIKO_CACHE_TTL: "24h"
  _SCAN: "false"
  _SIGN: "false"
  _SBOM: "false"
  _TEST: "true"
  _KMS_KEY: ""                      # gcpkms://...  (si vacío => firma keyless cosign)

steps:
  # Paso 0: Tests (auto-detección)
  - name: gcr.io/cloud-builders/gcloud
    id: tests
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        test_flag="$(echo "${_TEST}" | tr '[:upper:]' '[:lower:]')"
        if [ "$test_flag" != "true" ]; then
          echo "Tests omitidos (_TEST != true)."
          exit 0
        fi
        echo "Recolectando servicios para tests..."
        raw_input="${_SERVICES}"
        raw_input="$(echo "$raw_input" | tr ',' ' ' )"
        services_list=""
        for s in $raw_input; do
          [ -n "$s" ] || continue
          services_list+=" $s"
        done
        services_list="$(echo "$services_list" | xargs)"
        echo "Servicios: $services_list"
        failures=0
        for svc in $services_list; do
          dir="services/$svc"
          [ -d "$dir" ] || { echo "WARN: $dir no existe (saltando tests)"; continue; }
          echo "===> Ejecutando tests en $dir"
          pushd "$dir" >/dev/null
          if [ -f package.json ]; then
            if jq -e '.scripts.test' package.json >/dev/null 2>&1; then
              echo "Detectado Node.js: npm test"
              npm ci --ignore-scripts || npm install
              if ! npm test; then failures=$((failures+1)); fi
            fi
          elif [ -f pyproject.toml ] || ls *.py >/dev/null 2>&1; then
            echo "Detectado Python: pytest (si disponible) / fallback"
            python -m pip install --upgrade pip >/dev/null 2>&1 || true
            if grep -qi pytest pyproject.toml 2>/dev/null || grep -i pytest requirements.txt 2>/dev/null; then
              pip install -r requirements.txt >/dev/null 2>&1 || true
              pip install pytest >/dev/null 2>&1 || true
              if ! pytest -q; then failures=$((failures+1)); fi
            else
              echo "Sin suite explícita de tests, saltando."
            fi
          else
            echo "No se detectó tipo de proyecto con tests. Saltando."
          fi
          popd >/dev/null
        done
        if [ $failures -gt 0 ]; then
          echo "ERROR: $failures servicio(s) con fallos en tests."
          exit 1
        fi
        echo "Tests completados sin fallos."

  # Paso 1: Verificación de Dockerfiles
  - name: gcr.io/cloud-builders/gcloud
    id: verify-dockerfiles
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        raw_input="${_SERVICES}"
        raw_input="$(echo "$raw_input" | tr ',' ' ' )"
        services_list=""
        for s in $raw_input; do
          [ -n "$s" ] || continue
          services_list+=" $s"
        done
        services_list="$(echo "$services_list" | xargs)"
        echo "Servicios normalizados: $services_list"
        printf 'services_list="%s"
' "$services_list" > /workspace/services.env

        echo "Verificando Dockerfiles..."
        for svc in $services_list; do
          file="services/$svc/Dockerfile"
          if [ -f "$file" ]; then
            first=$(head -n1 "$file" || true)
            if ! grep -Eiq '^(FROM|ARG)' <<< "$first"; then
              echo "ADVERTENCIA: Primera línea de $file no comienza con FROM o ARG: '$first'"
            fi
            echo "OK: $file"
          else
            echo "ERROR: Falta $file" >&2
            exit 1
          fi
        done
        echo "Verificación completada."

  # Paso 2: Build & Push (Kaniko o Docker Buildx con cache)
  - name: gcr.io/cloud-builders/docker
    id: build-and-push
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        source /workspace/services.env
        builder_flag="$(echo "${_BUILDER}" | tr '[:upper:]' '[:lower:]')"
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        echo "Builder: $builder_flag"
        echo "Registro destino: $registry"
        extra_tag="${_EXTRA_TAG}"
        [ -n "$extra_tag" ] && echo "Tag extra: $extra_tag" || echo "Sin tag extra"

        if [ "$builder_flag" = "docker" ]; then
          echo "Inicializando buildx para cache..."
          docker buildx create --use --name sga-builder || docker buildx use sga-builder
        fi

        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          full_base="$registry/$image_base"
          context_dir="services/$svc"
          [ -d "$context_dir" ] || { echo "ERROR: No existe $context_dir"; exit 1; }
          echo "--------------------------------------------------"
          echo "Construyendo $svc -> $full_base"
          if [ "$builder_flag" = "kaniko" ]; then
            /usr/bin/env bash -c "
              docker run --rm \
                -v $(pwd):/workspace \
                -v /workspace/.kaniko-cache:/kaniko/cache \
                gcr.io/kaniko-project/executor:latest \
                  --context=dir://workspace/$context_dir \
                  --dockerfile=/workspace/$context_dir/Dockerfile \
                  --destination=$full_base:latest \
                  --destination=$full_base:$SHORT_SHA \
                  $( [ -n \"$extra_tag\" ] && echo --destination=$full_base:$extra_tag ) \
                  --cache=true \
                  --cache-ttl=${_KANIKO_CACHE_TTL} \
                  --verbosity=info
            "
          else
            cache_ref="$full_base:buildcache"
            docker buildx build \
              --pull \
              --cache-from type=registry,ref="$cache_ref" \
              --cache-to type=registry,ref="$cache_ref",mode=max \
              -t "$full_base:latest" \
              -t "$full_base:$SHORT_SHA" \
              $( [ -n "$extra_tag" ] && printf -- '-t %s:%s' "$full_base" "$extra_tag" ) \
              "$context_dir" \
              --push
            continue
          fi
          if [ "$builder_flag" = "kaniko" ]; then
            echo "Imágenes de $svc construidas y subidas."
          fi
        done
        echo "Build & Push completados."

  # Paso 3: Escaneo de vulnerabilidades (resumen)
  - name: gcr.io/cloud-builders/gcloud
    id: vulnerability-scan
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        scan_flag="$(echo "${_SCAN}" | tr '[:upper:]' '[:lower:]')"
        if [ "$scan_flag" != "true" ]; then
          echo "Escaneo omitido (_SCAN != true)."
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        echo "Esperando (30s) para que Container Analysis genere ocurrencias..."
        sleep 30
        printf '%-40s %-8s %-8s %-8s %-8s %-8s\n' "IMAGE" "CRIT" "HIGH" "MED" "LOW" "UNK"
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          out=$(gcloud artifacts docker images describe "$image" --project "$PROJECT_ID" --location "${_AR_REGION}" --format json || echo "{}");
          crit=$(echo "$out" | grep -o '"CRITICAL":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          high=$(echo "$out" | grep -o '"HIGH":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          med=$(echo "$out" | grep -o '"MEDIUM":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          low=$(echo "$out" | grep -o '"LOW":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          unk=$(echo "$out" | grep -o '"SEVERITY_UNSPECIFIED":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          printf '%-40s %-8s %-8s %-8s %-8s %-8s\n' "$image_base" "$crit" "$high" "$med" "$low" "$unk";
          if [ "
${crit:-0}" -gt 0 ]; then
            echo "ALERTA: $image_base con vulnerabilidades CRÍTICAS"
          fi
        done
        echo "Escaneo finalizado (solo resumen)."

  # Paso 4: Generación de SBOM (Syft) y attestation (cosign)
  - name: ghcr.io/anchore/syft:latest
    id: sbom
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        sbom_flag="$(echo "${_SBOM}" | tr '[:upper:]' '[:lower:]')"
        if [ "$sbom_flag" != "true" ]; then
          echo "SBOM omitido (_SBOM != true)."
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        mkdir -p /workspace/sbom
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          echo "Generando SBOM para $image"
          syft "$image" -o spdx-json > "/workspace/sbom/${image_base}.spdx.json"
        done
        echo "SBOMs generadas en /workspace/sbom"

  # Paso 5: Firma (cosign) + attestation SBOM
  - name: gcr.io/projectsigstore/cosign:v2.4.0
    id: sign-images
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        sign_flag="$(echo "${_SIGN}" | tr '[:upper:]' '[:lower:]')"
        if [ "$sign_flag" != "true" ]; then
          echo "Firma omitida (_SIGN != true)."
          exit 0;
        fi;
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        kms_key="${_KMS_KEY}"
        sbom_flag="$(echo "${_SBOM}" | tr '[:upper:]' '[:lower:]')"
        export COSIGN_EXPERIMENTAL=1
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          echo "Obteniendo digest de $image"
          digest=$(gcloud artifacts docker images describe "$image" --location "${_AR_REGION}" --project "$PROJECT_ID" --format 'value(image_summary.digest)' 2>/dev/null || true);
          if [ -z "$digest" ]; then
            echo "No se pudo obtener digest, intentando pull..."
            docker pull "$image";
            digest=$(docker inspect --format='{{index .RepoDigests 0}}' "$image" | cut -d'@' -f2);
          fi;
          [ -n "$digest" ] || { echo "ERROR: Digest no obtenido"; exit 1; };
          full_ref="$registry/$image_base@$digest";
          echo "Firmando $full_ref";
          if [ -n "$kms_key" ]; then
            cosign sign --yes --key "$kms_key" "$full_ref";
          else
            cosign sign --yes "$full_ref";
          fi;
          if [ "$sbom_flag" = "true" ]; then
            sbom_file="/workspace/sbom/${image_base}.spdx.json";
            if [ -f "$sbom_file" ]; then
              echo "Adjuntando attestation SBOM (in-toto) para $full_ref";
              if [ -n "$kms_key" ]; then
                cosign attest --yes --key "$kms_key" --predicate "$sbom_file" --type spdx "$full_ref";
              else
                cosign attest --yes --predicate "$sbom_file" --type spdx "$full_ref";
              fi;
            fi;
          fi;
        done;
        echo "Firma y attestation completadas."

  # Paso 6: Despliegue opcional a Cloud Run
  - name: gcr.io/cloud-builders/gcloud
    id: deploy
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        deploy_flag="$(echo "${_DEPLOY}" | tr '[:upper:]' '[:lower:]')"
        if [ "$deploy_flag" != "true" ]; then
          echo "Despliegue omitido (_DEPLOY != true)."
          exit 0;
        fi;
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        region="${_REGION}"
        for svc in $services_list; do
          image_base="${svc//_/-}-api";
          image="$registry/$image_base:latest";
          service_name="$image_base";
          echo "Deploy -> $service_name (imagen: $image)";
          gcloud run deploy "$service_name" \
            --image="$image" \
            --platform=managed \
            --region="$region" \
            --allow-unauthenticated \
            --project="$PROJECT_ID";
        done;
        echo "Despliegue completado."

  # Paso 7: Resumen final
  - name: gcr.io/cloud-builders/gcloud
    id: summary
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        echo "=== RESUMEN PIPELINE ==="
        echo "Servicios: ${_SERVICES}"
        echo "Builder: ${_BUILDER}"
        echo "Tests: ${_TEST}"
        echo "Scan: ${_SCAN}"
        echo "SBOM: ${_SBOM}"
        echo "Sign: ${_SIGN}"
        echo "Deploy: ${_DEPLOY}"
        echo "Extra tag: ${_EXTRA_TAG}"
        echo "Región AR: ${_AR_REGION}"
        echo "Región Deploy: ${_REGION}"
        echo "========================"

images:
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/core-sga-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/ai-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/risk-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/compliance-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/objectives-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/ghg-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/audit-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/auth-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/reporting-engine-api:latest
