# Cloud Build: construye, testea, escanea, genera SBOM, firma y despliega microservicios SGA.
#
# Ejemplos:
#   gcloud builds submit --config=cloudbuild.yaml
#   gcloud builds submit --config=cloudbuild.yaml --substitutions=_SERVICES="core_sga ai_engine",_DEPLOY="true",_SIGN="true",_SBOM="true"
#   gcloud builds submit --config=cloudbuild.yaml --substitutions=_EXTRA_TAG="staging",_SCAN="true"
#
# Ajusta las sustituciones según lo necesario.

timeout: 5400s
options:
  logging: CLOUD_LOGGING_ONLY
  machineType: E2_HIGHCPU_8

substitutions:
  _SERVICES: "core_sga,ai_engine,risk_engine,compliance_engine,objectives_engine,ghg_engine,audit_engine,auth_engine,reporting_engine"
  _EXTRA_TAG: ""
  _DEPLOY: "false"
  _REGION: "southamerica-east1"
  _AR_REGION: "us-central1"
  _BUILDER: "kaniko"                # kaniko | docker
  _KANIKO_CACHE_TTL: "24h"
  _SCAN: "false"
  _SIGN: "false"
  _SBOM: "false"
  _TEST: "true"
  _KMS_KEY: ""                      # gcpkms://... (si vacío => firma keyless cosign)

steps:
  # Paso 0: Función de normalización de servicios
  - name: gcr.io/cloud-builders/gcloud
    id: setup-functions
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        echo "Configurando funciones auxiliares..."
        
        # Función para normalizar la lista de servicios
        cat > /workspace/normalize_services.sh << 'EOF'
        #!/bin/bash
        normalize_services() {
          local raw_input="$1"
          raw_input="$(echo "$raw_input" | tr ',' ' ')"
          local services_list=""
          for s in $raw_input; do
            [ -n "$s" ] || continue
            services_list+=" $s"
          done
          services_list="$(echo "$services_list" | xargs)"
          echo "$services_list"
        }
        EOF
        
        chmod +x /workspace/normalize_services.sh
        echo "Funciones auxiliares configuradas correctamente."

  # Paso 1: Tests (auto-detección)
  - name: gcr.io/cloud-builders/gcloud
    id: tests
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        source /workspace/normalize_services.sh
        
        test_flag="$(echo "${_TEST}" | tr '[:upper:]' '[:lower:]')"
        if [ "$test_flag" != "true" ]; then
          echo "Tests omitidos (_TEST != true)."
          exit 0
        fi
        
        services_list=$(normalize_services "${_SERVICES}")
        echo "Servicios a probar: $services_list"
        
        failures=0
        for svc in $services_list; do
          dir="services/$svc"
          [ -d "$dir" ] || { echo "ADVERTENCIA: $dir no existe (saltando tests)"; continue; }
          echo "===> Ejecutando tests en $dir"
          pushd "$dir" >/dev/null
          if [ -f package.json ]; then
            if jq -e '.scripts.test' package.json >/dev/null 2>&1; then
              echo "Detectado Node.js: ejecutando npm test"
              (npm ci --ignore-scripts || npm install)
              if ! npm test; then failures=$((failures+1)); fi
            fi
          elif [ -f pyproject.toml ] || ls *.py >/dev/null 2>&1; then
            echo "Detectado Python: verificando pytest"
            python -m pip install --upgrade pip >/dev/null 2>&1 || true
            if grep -qi pytest pyproject.toml 2>/dev/null || grep -i pytest requirements.txt 2>/dev/null; then
              pip install -r requirements.txt >/dev/null 2>&1 || true
              pip install pytest >/dev/null 2>&1 || true
              if ! pytest -q; then failures=$((failures+1)); fi
            else
              echo "Sin suite explícita de tests, saltando."
            fi
          else
            echo "No se detectó tipo de proyecto con tests conocidos. Saltando."
          fi
          popd >/dev/null
        done
        if [ $failures -gt 0 ]; then
          echo "ERROR: $failures servicio(s) con fallos en tests."
          exit 1
        fi
        echo "Tests completados exitosamente sin fallos."

  # Paso 2: Verificación de Dockerfiles
  - name: gcr.io/cloud-builders/gcloud
    id: verify-dockerfiles
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        source /workspace/normalize_services.sh
        
        services_list=$(normalize_services "${_SERVICES}")
        echo "Servicios normalizados: $services_list"
        printf 'services_list="%s"\n' "$services_list" > /workspace/services.env

        echo "Verificando Dockerfiles..."
        for svc in $services_list; do
          file="services/$svc/Dockerfile"
          if [ -f "$file" ]; then
            first=$(head -n1 "$file" || true)
            if ! grep -Eiq '^(FROM|ARG)' <<< "$first"; then
              echo "ADVERTENCIA: Primera línea de $file no comienza con FROM o ARG: '$first'"
            fi
            echo "✓ Validado: $file"
          else
            echo "ERROR: Falta el archivo requerido $file" >&2
            exit 1
          fi
        done
        echo "Verificación de Dockerfiles completada exitosamente."

  # Paso 3A: Build & Push con Kaniko (si _BUILDER=kaniko)
  - name: gcr.io/kaniko-project/executor:latest
    id: build-and-push-kaniko
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        builder_flag="$(echo "${_BUILDER}" | tr '[:upper:]' '[:lower:]')"
        if [ "$builder_flag" != "kaniko" ]; then
          echo "Saltando step Kaniko (builder configurado como: $builder_flag)"
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        extra_tag="${_EXTRA_TAG}"
        mkdir -p /kaniko/cache
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          full_base="$registry/$image_base"
          context_dir="services/$svc"
          [ -d "$context_dir" ] || { echo "ERROR: No existe directorio $context_dir"; exit 1; }
          echo "===> Construyendo imagen para $svc con Kaniko"
          destinations="--destination=$full_base:latest --destination=$full_base:$SHORT_SHA"
          if [ -n "$extra_tag" ]; then
            destinations="$destinations --destination=$full_base:$extra_tag"
          fi
          /kaniko/executor \
            --context="dir://$PWD/$context_dir" \
            --dockerfile="$PWD/$context_dir/Dockerfile" \
            $destinations \
            --cache=true \
            --cache-ttl="${_KANIKO_CACHE_TTL}" \
            --verbosity=info
        done
        echo "Build con Kaniko completado exitosamente."

  # Paso 3B: Build & Push con Docker Buildx (si _BUILDER=docker)
  - name: gcr.io/cloud-builders/docker
    id: build-and-push-docker
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        builder_flag="$(echo "${_BUILDER}" | tr '[:upper:]' '[:lower:]')"
        if [ "$builder_flag" != "docker" ]; then
          echo "Saltando step Docker buildx (builder configurado como: $builder_flag)"
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        extra_tag="${_EXTRA_TAG}"
        docker buildx create --use --name sga-builder || docker buildx use sga-builder
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          full_base="$registry/$image_base"
          context_dir="services/$svc"
          [ -d "$context_dir" ] || { echo "ERROR: No existe directorio $context_dir"; exit 1; }
          cache_ref="$full_base:buildcache"
          echo "===> Construyendo imagen para $svc con Docker Buildx"
          build_tags="-t $full_base:latest -t $full_base:$SHORT_SHA"
          if [ -n "$extra_tag" ]; then
            build_tags="$build_tags -t $full_base:$extra_tag"
          fi
          docker buildx build \
            --pull \
            --cache-from type=registry,ref="$cache_ref" \
            --cache-to type=registry,ref="$cache_ref",mode=max \
            $build_tags \
            "$context_dir" \
            --push
        done
        echo "Build con Docker Buildx completado exitosamente."

  # Paso 4: Escaneo de vulnerabilidades (resumen)
  - name: gcr.io/cloud-builders/gcloud
    id: vulnerability-scan
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        scan_flag="$(echo "${_SCAN}" | tr '[:upper:]' '[:lower:]')"
        if [ "$scan_flag" != "true" ]; then
          echo "Escaneo de vulnerabilidades omitido (_SCAN != true)."
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        echo "Esperando análisis de Container Analysis (30s)..."
        sleep 30
        printf '%-40s %-6s %-6s %-6s %-6s %-6s\n' "IMAGE" "CRIT" "HIGH" "MED" "LOW" "UNK"
        echo "$(printf '=%.0s' {1..76})"
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          out=$(gcloud artifacts docker images describe "$image" \
                  --project "$PROJECT_ID" --location "${_AR_REGION}" \
                  --format json 2>/dev/null || echo "{}");
          crit=$(echo "$out" | grep -o '"CRITICAL":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          high=$(echo "$out" | grep -o '"HIGH":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          med=$(echo "$out" | grep -o '"MEDIUM":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          low=$(echo "$out" | grep -o '"LOW":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          unk=$(echo "$out" | grep -o '"SEVERITY_UNSPECIFIED":[0-9]*' | head -1 | cut -d: -f2 || echo 0);
          printf '%-40s %-6s %-6s %-6s %-6s %-6s\n' "$image_base" "$crit" "$high" "$med" "$low" "$unk";
          if [ "${crit:-0}" -gt 0 ]; then
            echo "⚠️  ALERTA: $image_base tiene vulnerabilidades CRÍTICAS"
          fi
        done
        echo "Escaneo de vulnerabilidades finalizado (resumen mostrado)."

  # Paso 5: Generación de SBOM (Syft)
  - name: ghcr.io/anchore/syft:latest
    id: sbom
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        sbom_flag="$(echo "${_SBOM}" | tr '[:upper:]' '[:lower:]')"
        if [ "$sbom_flag" != "true" ]; then
          echo "Generación de SBOM omitida (_SBOM != true)."
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        mkdir -p /workspace/sbom
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          echo "Generando SBOM para $image"
          syft "$image" -o spdx-json > "/workspace/sbom/${image_base}.spdx.json"
        done
        echo "SBOMs generadas exitosamente."

  # Paso 6: Firma (cosign) + attestation SBOM
  - name: gcr.io/projectsigstore/cosign:v2.4.0
    id: sign-images
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        sign_flag="$(echo "${_SIGN}" | tr '[:upper:]' '[:lower:]')"
        if [ "$sign_flag" != "true" ]; then
          echo "Firma de imágenes omitida (_SIGN != true)."
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        kms_key="${_KMS_KEY}"
        sbom_flag="$(echo "${_SBOM}" | tr '[:upper:]' '[:lower:]')"
        export COSIGN_EXPERIMENTAL=1
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          echo "Obteniendo digest de $image"
          digest=$(gcloud artifacts docker images describe "$image" \
                     --location "${_AR_REGION}" --project "$PROJECT_ID" \
                     --format 'value(image_summary.digest)' 2>/dev/null || true);
          if [ -z "$digest" ]; then
            echo "Digest no disponible vía metadata; obteniendo con pull local."
            docker pull "$image";
            digest=$(docker inspect --format='{{index .RepoDigests 0}}' "$image" | cut -d'@' -f2);
          fi
          [ -n "$digest" ] || { echo "ERROR: No se pudo obtener digest"; exit 1; }
          full_ref="$registry/$image_base@$digest";
          echo "Firmando imagen: $full_ref";
          if [ -n "$kms_key" ]; then
            cosign sign --yes --key "$kms_key" "$full_ref";
          else
            cosign sign --yes "$full_ref";
          fi
          if [ "$sbom_flag" = "true" ]; then
            sbom_file="/workspace/sbom/${image_base}.spdx.json";
            if [ -f "$sbom_file" ]; then
              echo "Creando attestation SBOM (spdx) para $full_ref";
              if [ -n "$kms_key" ]; then
                cosign attest --yes --key "$kms_key" --predicate "$sbom_file" --type spdx "$full_ref";
              else
                cosign attest --yes --predicate "$sbom_file" --type spdx "$full_ref";
              fi
            fi
          fi
        done
        echo "Firma y attestation completadas exitosamente."

  # Paso 7: Despliegue opcional a Cloud Run
  - name: gcr.io/cloud-builders/gcloud
    id: deploy
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        deploy_flag="$(echo "${_DEPLOY}" | tr '[:upper:]' '[:lower:]')"
        if [ "$deploy_flag" != "true" ]; then
          echo "Despliegue a Cloud Run omitido (_DEPLOY != true)."
          exit 0
        fi
        source /workspace/services.env
        registry="${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services"
        region="${_REGION}"
        for svc in $services_list; do
          image_base="${svc//_/-}-api"
          image="$registry/$image_base:latest"
          service_name="$image_base"
          echo "Desplegando servicio: $service_name (imagen: $image)"
          gcloud run deploy "$service_name" \
            --image="$image" \
            --platform=managed \
            --region="$region" \
            --allow-unauthenticated \
            --project="$PROJECT_ID";
        done
        echo "Despliegue a Cloud Run completado exitosamente."

  # Paso 8: Resumen final
  - name: gcr.io/cloud-builders/gcloud
    id: summary
    entrypoint: bash
    args:
      - -c
      - |
        set -euo pipefail
        echo "========================================="
        echo "         RESUMEN DEL PIPELINE            "
        echo "========================================="
        echo "Servicios procesados: ${_SERVICES}"
        echo "Builder utilizado: ${_BUILDER}"
        echo "Tests ejecutados: ${_TEST}"
        echo "Escaneo de vulnerabilidades: ${_SCAN}"
        echo "Generación de SBOM: ${_SBOM}"
        echo "Firma de imágenes: ${_SIGN}"
        echo "Despliegue a Cloud Run: ${_DEPLOY}"
        echo "Tag adicional: ${_EXTRA_TAG:-"(ninguno)"}"
        echo "Región Artifact Registry: ${_AR_REGION}"
        echo "Región de despliegue: ${_REGION}"
        echo "========================================="
        echo "Pipeline completado exitosamente ✓"

images:
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/core-sga-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/ai-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/risk-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/compliance-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/objectives-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/ghg-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/audit-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/auth-engine-api:latest
  - ${_AR_REGION}-docker.pkg.dev/$PROJECT_ID/sga-services/reporting-engine-api:latest